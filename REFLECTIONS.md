# Tenets & Learnings
## Or, what am I trying to do here?

This repository contains multiple implementations of the same algorithm, a Monte Carlo simulation of a retirement portfolio drawing down during retirement, in multiple languages and multiple UI technologies. 

Why? To sharpen my skills and survey the landscape. It's like asking a pianist why they are practicing or why a pianist might also want to learn guitar. My career has taken me from hands-on dev, to manager, to manager-of-managers, and I want to improve my coding skills. 

As I learn and explore, I am evaluating these technologies for fit to my programming ideals. That's the purpose of this document. 

## Tenets
* **Meet customers where they are.** You need an app on every surface. You need a web site. Your customers use iOS, Android, Windows, Mac, and Linux. You need it all, you can't afford to write six different UIs, and your customers need to experience your complete product everywhere. 
* **Prefer fungible engineering skills, and minimize the number of skills needed.** This makes hiring and horse-trading easier if you can hire generalists that can have an impact in any part of the code base. This means I prefer write-once-run-anywhere paradigms like Flutter and .NET Maui over a proliferation of languages for each platform (JS, Swift, Kotlin, etc). I also prefer the same tech stack on the backend as the front end. Finally, this means that you should pick technology that has a large talent pool and abundant online resources. 
* **Speed matters in business.** Stealing from Amazon's *Bias for Action* leadership principle, engineering velocity and time to market almost always matter more than raw computing performance. You need to be able to make decisions quickly, build & ship quickly, and iterate quickly. If you don't, your competitor will. This also means you need to focus on writing code that is the unique value that your business provides; you shouldn't be writing utility code or UI toolkits, for example. 
* **Worse is better.** Sometimes you just need to make an imperfect decision in the interest of getting the product out there and getting customer feedback. In general, trim scope & corner cases in favor of shipping speed.  E.g. building an Electron app is bloated and slow - but so what? Web technologies are generally good enough, except for the rare occasions where raw compute power matters more (e.g. shipping to constrained embedded devices or algorithm hot spots). "[The lesson](https://www.dreamsongs.com/RiseOfWorseIsBetter.html) to be learned from this is that it is often undesirable to go for the right thing first. It is better to get half of the right thing available so that it spreads."
* **Fight decision fatigue, prefer batteries-included.** The prior two bullets yield this result. It's almost always better to have everything you need at your fingertips because the frameworks upon which your software is built provide everything you need. I admire Rust, but the stdlib is bare, and even something like choosing a library for arbitrary precision `decimal` data types requires sifting through a half dozen crates and finding the one that is the best fit for your needs. This slows you down. Node is even worse. 
* **Prefer programming languages that eliminate bugs at compile time vs at run time.** In other words, I like static types because they let you prove (certain types of) correctness of your program when you're writing code, not in the field later. Compiler features, null safety, and/or static analysis can help here. 
* **Memory safety is non-negotiable.** Memory safety bugs are still the [root cause of 60% of security vulnerabilities](https://security.googleblog.com/2021/01/data-driven-security-hardening-in.html). Can be achieved by static analysis/compiler (Rust) or garbage collection (.NET, Go, Dart). 
* **Thread safety is non-negotiable.** In general, never use a mutex or `lock` statement ever again. To quote Go: *"Don't communicate by sharing memory, share memory by communicating."* Use Channel pattern or other built-in primitives (Parallel.ForEach and System.Collections.Concurrent in C#) that provide thread safety for you. 
* **Unit test your important code, but don't overdo it.** I used to espouse 70%+ coverage as a rule, but lately I've back-pedalled. I read something about how Facebook survived their first ~decade with zero--*literally zero*--unit tests. They had good release processes to roll back bugs, and let's face it, it's a web site for looking at pictures of your friends. This is not life-or-death stuff. Write tests when the code is critical, when the dev-break-fix loop needs to go faster, or when you're refactoring (preserve input/output of APIs). But speed matters in business, and sometimes it's okay to ship a bug. 
* **Monorepo?** Still not sure about this one, but I have experienced the pain of dependency management. Monorepo can have its own challenges, but being able to work with a snapshot of your codebase with *all* of its dependencies in that snapshot, sure sounds nice. 
* **Different technologies attract different types of engineers.** What kind of engineers do you want on your team? Explorers who are up to date on all the latest open source? Slapdash coders who get it done but it's unmaintainable? Craftspeople who think code is beautiful art? Doers who follow orders but don't make decisions? Tinkerers who love nuts & bolts? 


## Thoughts on things I've looked at

`/usr/bin/time -v` on the respective command. Release mode. 

* Go release mode `go build -ldflags "-s -w"`
* `dotnet publish -c Release && ./bin/Release/net7.0/linux-x64/native/DrawdownDotNet`
  * `<PublishAot>true</PublishAot><StripSymbols>true</StripSymbols>`

| Language                             | Elapsed (wall clock) time | Maximum resident set (KB) | Executable Size |
|--------------------------------------|---------------------------|---------------------------|-----------------|
| Rust                                 | 0.31s                     | 325,568                   | 4.3M            |
| C# Native AOT (RangePartitioner)     | 1.34s                     | 669,368                   | 8.8M            |
| C# Native AOT (Parallel.ForEach)     | 1.36s                     | 670,108                   | 8.8M            |
| Go (one goroutine per iteration)     | 1.58s                     | 1,138,860                 | 1.7M            |
| Go (one goroutine per CPU thread)    | 1.80s                     | 1,031,936                 | 1.7M            |
| C# (.NET Runtime, Parallel.ForEach)  | 2.87s                     | 674,840                   | Framework req'd |
| C# (.NET Runtime, RangePartitioner)  | 2.88s                     | 663,428                   | Framework req'd |
| Deno Typescript                      | 9.87s                     | 730,828                   | Framework req'd |

* Rust's approach and compiler are *awesome,* but the learning curve is *steep.* There were a few times I was stuck for half a day trying to figure out what I was doing wrong. The solution was usually easy: in one case I needed to use a Scoped Thread and not a 'regular' thread. Then I learned about Rayon, a third-party crate that provides parallel iterators. It was simple in the end, but slow to diagnose and move forward, took me three attempts to implement 'right,' why do I need a third-party library to have parallel iterators anyway, and Rayon isn't compatible with WASM threads so I need to go back to scoped threads? All that said - once Rust code compiles, it works--it's difficult to cause a runtime panic. And it runs *fast*. Rust completed the Monte Carlo algorithm, a CPU-bound computation, in less than 1/5 the time of C# NativeAOT. I advise against using Rust as a general purpose language. For compute-sensitive operations, you can interop-call out to Rust, which can compile to run everywhere. 
* Rust takes a different approach to OOP, using [Traits](https://en.wikipedia.org/wiki/Trait_(computer_programming)), and not supporting inheritance. I had a few struggles with the learning curve, e.g. you can't take a trait as a parameter without using a generic. Rust's learning curve is steep. You can model traits pretty closely with interfaces in C#/Java etc, and in general I like the principle of describing the features you need the object to support rather than taking in a whole class hierarchy. 
* Deno/JS/TypeScript. Deno is a nice improvement from Node. TypeScript first. I love TypeScript, the type system is amazing. But every time I use it I think: I wish this weren't built on something as crappy as JavaScript. JS suffers from the decision fatigue of a poor stdlib but a massive community. Deno provides a nice stdlib but it's not complete. JS is still single-threaded (LOL). The main argument for JS/TS was that you could use one language *everywhere*--but as WASM/WASI catch on, that argument is evaporating. 
* Put your build infra in a Docker container. Every project starts with a script to bootstrap development, but eventually it falls into disrepair. A Dockerfile forces it. 
* WASM/WASI is going to be the *next big thing.* It'll replace Docker as the universal packaging PLUS with a universal runtime format. Running a WASI package feels a heck of a lot like spinning up a Docker container. The main difference is, there's a WASM interpreter or compiler in the middle. I think we'll get to a point where *every* major language can compile to WASI, and it'll become the default. For cloud hosts, it means the end customer can compile their code to WASM and ask the host to run it. The cloud host can procure whatever economically viable compute they can, x64/ARM doesn't matter. They can run the code on any hardware that happens to be free. Compiling to a single ABI is going to make a heck of a lot of peoples' lives a heck of a lot easier. Even though Microsoft haven't publicly committed to it, the writing is on the wall; check out Steve Sanderson's [talk](https://learn.microsoft.com/en-us/events/build-2022/od108-future-possibilities-net-core-wasi-webassembly-on-server) and [prototype](https://github.com/SteveSandersonMS/dotnet-wasi-sdk). 
* .NET Maui is so close to what I want. C# and native UI everywhere *except* the web. But then you can use .NET Maui Hybrid aka Maui Blazor, which uses the platform-native web renderer to run your C# as native code with an HTML-based UI on every platform, no WASM involved. It's definitely "worse is better." It's better than Electron, it uses fungible skills (C#, HTML, and no JavaScript). HTML is more fungible than  Xamarin Forms. [The genesis of Blazor Hybrid](https://blog.stevensanderson.com/2019/11/18/2019-11-18-webwindow-a-cross-platform-webview-for-dotnet-core/) gives a good breakdown of how it works under the covers (and it's Steve Sanderson, again). [This open source library](https://github.com/jspuij/TwokaB) is what Microsoft built upon to make it a reality.
* I'm really excited about [.NET Native AOT](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/#platformarchitecture-restrictions) - but so far it only supports Windows and Linux Arm64/x64 targets. Given what we've seen from MSFT on WASI, and [old blog posts hint at iOS support](https://visualstudiomagazine.com/articles/2022/04/15/net-7-preview-3.aspx), I think that'll come too, as well as Android, iOS, and MacOS. And I presume this will merge into Maui & WASI as well. I'm impressed with its runtime performance, though obviously it doesn't match Rust, for ease of development nothing tops it. Parallel.ForEach is *easy mode* and it worked great - no material improvements using a RangePartitioner to pre-chunk the work per CPU thread. 
* Flutter/Dart is a darling for front-end development. It really does run everywhere. Declare your UI in code and it will compile everywhere. Hot reload that really just works, even for adding new dependencies. Maybe I should look into Dart on the server. 
* Uno Platform looks compelling. It's a fork of Xamarin.Forms and is thus a direct competitor to .NET Maui with one notable exception: They have a Web binding and can compile to WASM. Pretty neat, but I'm leery of hitching my wagon to an open source product like that. Maybe .NET Maui for everything except web, and Uno for web?
* Go seems good. It is very approachable (ported the algorithm in an afternoon), makes tiny self-contained executables that run quickly (not as quick as rust). Goroutines for concurrency are pretty approachable but my first attempt deadlocked and it took a while to figure out why (`for val := range channel` will deadlock if the channel is still open and there's no more data; close the channel, explicitly loop if you know how many iterations, or use `sync.WaitGroup` to count writes/reads to/from channel). I'm surprised the channel construct is that persnickety, and since it's a language construct, not a module in stdlib, we're kinda stuck with it. I was able to build the entire algorithm with no dependencies (unlike rust), hence a tidy binary size. Goroutines are, as promised, lightweight, and there was no difference spinning up 100k (one per trial) and 8 (one per CPU thread). One sweet spot for Go is small, standalone native utilities (especially when packed into a Docker image). Are there good UI toolkits for it that run everywhere? Can it make a native library and be easily called from Flutter? 

## Bottom line

So what do I recommend? Since there's no one-size-fits all, here are a few viable configurations. 

* C# everywhere with .NET Maui Blazor Hybrid. Particularly CPU-intensive parts of an algorithm *may* be worth writing in Rust (but it would have to be an algorithm that causes the customer to wait a frustrating amount of time and that has to happen on their device/you can't throw a bigger server at it). 
* Go everywhere with Flutter frontend. Seems possible from some quick tutorials. TBD how good this is, and I don't know Go yet. [ref](https://medium.com/flutter-community/using-go-library-in-flutter-a04e3496aa05), [wasm](https://tinygo.org/docs/guides/webassembly/), [c headers from go](https://github.com/golang/go/issues/35715), [dart bindings from c headers ffigen](https://pub.dev/packages/ffigen), [more discussion](https://github.com/archanpaul/medium-flutter_with_go/issues/3).
* C# everywhere with .NET Maui for everywhere except web, and Uno Platform for Web (TBD if this is possible) until Microsoft [adds web support to Maui](https://github.com/dotnet/maui/discussions/62).
* In the future, Flutter with .NET NativeAOT. Maybe there's some way to use Maui to compile the native code and interop it to Flutter?
* For low-powered/constrained/embedded systems, probably [Rust with Flutter](https://pub.dev/packages/flutter_rust_bridge). I'm not sure how well Flutter does on [embedded hardware](https://flutter.dev/multi-platform/embedded), so maybe Rust + Skia (Flutter uses Skia for rendering). Possibly Rust to WASM + [Skia Canvas](https://skia.org/docs/user/api/skcanvas_overview/) for web. 